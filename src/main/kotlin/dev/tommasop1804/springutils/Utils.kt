@file:JvmName("UtilsKt")
@file:Suppress("unused")

package dev.tommasop1804.springutils

import dev.tommasop1804.kutils.*
import dev.tommasop1804.kutils.classes.coding.JSON.Companion.toJSON
import dev.tommasop1804.kutils.classes.time.TimeZone
import dev.tommasop1804.kutils.exceptions.MalformedInputException
import dev.tommasop1804.springutils.annotations.Feature
import org.springframework.http.HttpHeaders
import java.lang.reflect.Method
import java.time.Instant
import java.time.ZoneOffset.UTC
import java.time.format.DateTimeFormatter
import java.time.temporal.TemporalAccessor

/**
 * Computes a unique hash-based identifier (eTag) for the current object.
 *
 * The eTag is generated by converting the object to its JSON representation
 * and then applying an MD5 hash algorithm to produce a hexadecimal string.
 * This identifier can be used for caching, validation, and resource versioning purposes.
 * @since 1.0.0
 */
val Any.eTag
    get() = toJSON().value hashingToString HashingAlgorithm.MD5

/**
 * Constructs an instance of `HttpHeaders` from the provided key-value pairs, where each key
 * represents the name of the header and each value is a list of objects. The objects are
 * converted to their string representations to define the header values.
 *
 * @param headers pairs of header names and their corresponding lists of values, where the
 * values are converted to strings and associated with the header name in the `HttpHeaders`.
 * @since 1.0.0
 */
fun HttpHeaders(
    vararg headers: Pair<String, AnyList>
) = HttpHeaders().apply { putAll(headers.associate { it.first to it.second.map(Any::toString) }) }
/**
 * Creates an instance of `HttpHeaders` and populates it with the provided headers.
 *
 * Each header is represented as a key-value pair, where the key is a `String` and the value
 * is converted to its `String` representation. If multiple headers are provided, they are
 * combined into a single `HttpHeaders` instance.
 *
 * @param headers vararg of header pairs, where each pair consists of a header name (key)
 * and its corresponding value. The value will be converted to a `String`.
 * @since 1.0.0
 */
@JvmName("httpHeadersOfAny")
fun HttpHeaders(
    vararg headers: Pair<String, Any>
) = HttpHeaders().apply { putAll(headers.associate { it.first to it.second.toString().asSingleList() }) }

/**
 * Converts a string representation of a date, commonly found in HTTP headers, into an [Instant].
 *
 * The input string is expected to follow the format "WeekDay, Day Month Year Time TZ" (e.g., "Tue, 15 Nov 1994 08:12:31 GMT").
 *
 * @receiver The date string to be converted.
 * @return The corresponding [Instant] representation of the date.
 * @throws MalformedInputException If the month in the input string is invalid or if the format does not match expectations.
 * @since 1.0.0
 */
fun String.headerDateToInstant(): Instant =
    tryOrThrow({ -> MalformedInputException(Instant::class) }) {
        if (ISO_DATE_TIME_STANDARD_VALIDATOR(this)) return@tryOrThrow Instant(this)()
        val splitted = this / Char.SPACE
        val day = splitted[1].toInt()
        val month = when (splitted[2]) {
            "Jan" -> 1
            "Feb" -> 2
            "Mar" -> 3
            "Apr" -> 4
            "May" -> 5
            "Jun" -> 6
            "Jul" -> 7
            "Aug" -> 8
            "Sep" -> 9
            "Oct" -> 10
            "Nov" -> 11
            "Dec" -> 12
            else -> throw IllegalArgumentException("Invalid month format")
        }
        val year = splitted[3].toInt()
        val time = LocalTime(splitted[4])()
        LocalDateTime(LocalDate(year, month, day), time).toInstant((TimeZone of splitted[5]).firstOrNull()?.offset ?: UTC)
    }

/**
 * Converts the invoking [TemporalAccessor] instance, such as a date-time object, into a string
 * formatted according to the RFC 1123 date time standard.
 *
 * This method is commonly used in scenarios requiring date-time values suitable for HTTP headers
 * and similar use cases.
 *
 * @return A string representation of the date-time in the RFC 1123 date time format.
 */
fun TemporalAccessor.toHeaderDate(): String = DateTimeFormatter.RFC_1123_DATE_TIME.format(this)

internal fun findCallerMethod(): Method? = tryOrNull {
    val stackTrace = Thread.currentThread().stackTrace

    for (i in 3 until stackTrace.size) {
        val element = stackTrace[i]
        try {
            val clazz = Class.forName(element.className)
            val methods = clazz.declaredMethods

            val method = methods.find {
                it.name == element.methodName
            }

            if (method?.getAnnotation(Feature::class.java).isNotNull())
                return@tryOrNull method
        } catch (e: Exception) {
            continue
        }
    }
    null
}