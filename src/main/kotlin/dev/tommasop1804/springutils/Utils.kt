@file:JvmName("UtilsKt")
@file:Suppress("unused", "FunctionName")

package dev.tommasop1804.springutils

import dev.tommasop1804.kutils.*
import dev.tommasop1804.kutils.classes.coding.JSON.Companion.toJSON
import dev.tommasop1804.kutils.classes.time.TimeZone
import dev.tommasop1804.kutils.exceptions.*
import dev.tommasop1804.springutils.annotations.Feature
import dev.tommasop1804.springutils.exception.*
import org.springframework.http.HttpHeaders
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.security.authentication.LockedException
import java.lang.reflect.Method
import java.net.URI
import java.time.Instant
import java.time.ZoneOffset.UTC
import java.time.format.DateTimeFormatter
import java.time.temporal.TemporalAccessor

/**
 * Computes a unique hash-based identifier (eTag) for the current object.
 *
 * The eTag is generated by converting the object to its JSON representation
 * and then applying an MD5 hash algorithm to produce a hexadecimal string.
 * This identifier can be used for caching, validation, and resource versioning purposes.
 * @since 1.0.0
 */
val Any.eTag
    get() = toJSON().value hashingToString HashingAlgorithm.MD5

/**
 * Constructs an instance of `HttpHeaders` from the provided key-value pairs, where each key
 * represents the name of the header and each value is a list of objects. The objects are
 * converted to their string representations to define the header values.
 *
 * @param headers pairs of header names and their corresponding lists of values, where the
 * values are converted to strings and associated with the header name in the `HttpHeaders`.
 * @since 1.0.0
 */
fun HttpHeaders(
    vararg headers: Pair<String, AnyList>
) = HttpHeaders().apply { putAll(headers.associate { it.first to it.second.map(Any::toString) }) }
/**
 * Creates an instance of `HttpHeaders` and populates it with the provided headers.
 *
 * Each header is represented as a key-value pair, where the key is a `String` and the value
 * is converted to its `String` representation. If multiple headers are provided, they are
 * combined into a single `HttpHeaders` instance.
 *
 * @param headers vararg of header pairs, where each pair consists of a header name (key)
 * and its corresponding value. The value will be converted to a `String`.
 * @since 1.0.0
 */
@JvmName("httpHeadersOfAny")
fun HttpHeaders(
    vararg headers: Pair<String, Any>
) = HttpHeaders().apply { putAll(headers.associate { it.first to it.second.toString().asSingleList() }) }

fun ProblemDetail(
    title: String? = null,
    status: HttpStatus,
    type: URI? = null,
    detail: String? = null,
    instance: URI? = null,
    internalErrorCode: String? = null,
    exception: String? = null,
    extensions: DataMapNN = emptyMap()
): ExceptionHandler.ExtendedProblemDetail {
    val result = ProblemDetail.forStatus(status)
    if (title.isNotNull()) result.title = title
    if (type.isNotNull()) result.type = type
    if (detail.isNotNull()) result.detail = detail
    if (instance.isNotNull()) result.instance = instance
    for ((key, value) in extensions) result.setProperty(key, value)
    return ExceptionHandler.ExtendedProblemDetail(result, internalErrorCode, exception)
}
fun ProblemDetail(
    title: String? = null,
    status: Int,
    type: URI? = null,
    detail: String? = null,
    instance: URI? = null,
    internalErrorCode: String? = null,
    exception: String? = null,
    extensions: DataMapNN = emptyMap()
): ExceptionHandler.ExtendedProblemDetail {
    val result = ProblemDetail.forStatus(status)
    if (title.isNotNull()) result.title = title
    if (type.isNotNull()) result.type = type
    if (detail.isNotNull()) result.detail = detail
    if (instance.isNotNull()) result.instance = instance
    for ((key, value) in extensions) result.setProperty(key, value)
    return ExceptionHandler.ExtendedProblemDetail(result, internalErrorCode, exception)
}

/**
 * Converts a string representation of a date, commonly found in HTTP headers, into an [Instant].
 *
 * The input string is expected to follow the format "WeekDay, Day Month Year Time TZ" (e.g., "Tue, 15 Nov 1994 08:12:31 GMT").
 *
 * @receiver The date string to be converted.
 * @return The corresponding [Instant] representation of the date.
 * @throws MalformedInputException If the month in the input string is invalid or if the format does not match expectations.
 * @since 1.0.0
 */
fun String.headerDateToInstant(): Instant =
    tryOrThrow({ -> MalformedInputException(Instant::class) }) {
        if (ISO_DATE_TIME_STANDARD_VALIDATOR(this)) return@tryOrThrow Instant(this)()
        val splitted = this / Char.SPACE
        val day = splitted[1].toInt()
        val month = when (splitted[2]) {
            "Jan" -> 1
            "Feb" -> 2
            "Mar" -> 3
            "Apr" -> 4
            "May" -> 5
            "Jun" -> 6
            "Jul" -> 7
            "Aug" -> 8
            "Sep" -> 9
            "Oct" -> 10
            "Nov" -> 11
            "Dec" -> 12
            else -> throw IllegalArgumentException("Invalid month format")
        }
        val year = splitted[3].toInt()
        val time = LocalTime(splitted[4])()
        LocalDateTime(LocalDate(year, month, day), time).toInstant((TimeZone of splitted[5]).firstOrNull()?.offset ?: UTC)
    }

/**
 * Converts the invoking [TemporalAccessor] instance, such as a date-time object, into a string
 * formatted according to the RFC 1123 date time standard.
 *
 * This method is commonly used in scenarios requiring date-time values suitable for HTTP headers
 * and similar use cases.
 *
 * @return A string representation of the date-time in the RFC 1123 date time format.
 */
fun TemporalAccessor.toHeaderDate(): String = DateTimeFormatter.RFC_1123_DATE_TIME.format(this)

internal fun findCallerMethod(): Method? = tryOrNull {
    val stackTrace = Thread.currentThread().stackTrace

    for (i in 2 until stackTrace.size) {
        val element = stackTrace[i]
        try {
            if (element.className.startsWith("java.") || element.className.startsWith("kotlin.")) continue
            val clazz = Class.forName(element.className)
            val methods = clazz.declaredMethods

            val method = methods.find {
                it.name == element.methodName
            }

            if (method?.getAnnotation(Feature::class.java).isNotNull())
                return@tryOrNull method
        } catch (e: Exception) {
            continue
        }
    }
    null
}

internal fun getStatus(e: Throwable) = when (e) {
    is BadGatewayException, is ExternalServiceHttpException -> HttpStatus.BAD_GATEWAY
    is BadRequestException, is RequiredFieldException, is RequiredParameterException -> HttpStatus.BAD_REQUEST
    is ConflictException, is ResourceAlreadyExistsException, is ResourceConflictException -> HttpStatus.CONFLICT
    is ExpectationFailedException -> HttpStatus.EXPECTATION_FAILED
    is FailedDependencyException -> HttpStatus.FAILED_DEPENDENCY
    is ForbiddenException, is InsufficientPermissionsException -> HttpStatus.FORBIDDEN
    is GatewayTimeoutException -> HttpStatus.GATEWAY_TIMEOUT
    is GoneException -> HttpStatus.GONE
    is InsufficientStorageException -> HttpStatus.INSUFFICIENT_STORAGE
    is LengthRequiredException -> HttpStatus.LENGTH_REQUIRED
    is LockedException, is ResourceLockedException -> HttpStatus.LOCKED
    is LoopDetectedException -> HttpStatus.LOOP_DETECTED
    is MisdirectedRequestException -> HttpStatus.MISDIRECTED_REQUEST
    is NetworkAuthenticationRequiredException -> HttpStatus.NETWORK_AUTHENTICATION_REQUIRED
    is NotAcceptableException -> HttpStatus.NOT_ACCEPTABLE
    is NotExtendedException -> HttpStatus.NOT_EXTENDED
    is NotFoundException, is ResourceNotFoundException -> HttpStatus.NOT_FOUND
    is NotImplementedException -> HttpStatus.NOT_IMPLEMENTED
    is PayloadTooLargeException -> HttpStatus.PAYLOAD_TOO_LARGE
    is PaymentRequiredException -> HttpStatus.PAYMENT_REQUIRED
    is PreconditionFailedException -> HttpStatus.PRECONDITION_FAILED
    is PreconditionRequiredException -> HttpStatus.PRECONDITION_REQUIRED
    is RangeNotSatisfiableException -> HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE
    is RequestTimeoutException -> HttpStatus.REQUEST_TIMEOUT
    is TeapotException -> HttpStatus.I_AM_A_TEAPOT
    is TooEarlyException -> HttpStatus.TOO_EARLY
    is TooManyRequestsException -> HttpStatus.TOO_MANY_REQUESTS
    is UnauthorizedException -> HttpStatus.UNAUTHORIZED
    is UnavailableForLegalReasonsException -> HttpStatus.UNAVAILABLE_FOR_LEGAL_REASONS
    is UnprocessableEntityException, is ResourceNotAcceptableException -> HttpStatus.UNPROCESSABLE_ENTITY
    is UnsupportedMediaTypeException -> HttpStatus.UNSUPPORTED_MEDIA_TYPE
    else -> HttpStatus.INTERNAL_SERVER_ERROR
}